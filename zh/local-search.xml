<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>控制 WSL 2 实例的内存占用</title>
    <link href="/zh/2021/11/02/Control-the-memory-usage-of-WSL-2-instance/"/>
    <url>/zh/2021/11/02/Control-the-memory-usage-of-WSL-2-instance/</url>
    
    <content type="html"><![CDATA[<p>前段日子重装了我的台式机里面的 Linux 子系统，顺便把子系统版本从 WSL1 迁移到了 WSL2。</p><p>WSL2 实质上是一个 Hyper-V 虚拟机，只是里面跑的是微软为 Hyper-V 高度优化后的 Linux 内核，于是 WSL2 冷启动速度非常迅速，在我的台式机上不到一秒钟就能完成其冷启动全过程。</p><p>由于 WSL2 实质是个虚拟机而不是 WSL1 那种把 Linux 系统调用翻译成 Windows 系统调用的方式，于是在 I/O 操作这种系统调用密集型操作上效率有了质的提升，而且还支持挂载 ext4 等 Windows 本身不支持的文件系统。</p><p>然而我在用 WSL2 的一开始就因为使用 apt 安装 texlive 的时候发现内存占用爆表，最后研究了下是 Linux 内核文件缓存占了非常多的内存而且既然是缓存那么大概率是不会释放的，于是 Hyper-V 即使支持智能释放虚拟机空闲内存也起不了多少作用。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在用户配置目录下创建了 <code>.wslconfig</code> 文件，然后填入了以下内容保存后问题成功解决。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[wsl2]</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">4</span>GB<br></code></pre></td></tr></table></figure><h2 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h2><ul><li>Windows 10 Build 20175 及之后版本<ul><li>最大占用 Windows 可使用的总内存的 50% 或 8GB (以较小者为准)</li></ul></li><li>Windows 10 Build 20175 之前版本<ul><li>最大占用 Windows 可使用的总内存的 80%</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig">https://docs.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig</a></li></ul><h2 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h2><a href="/zh/2021/11/02/Windows-Research-Notes/" title="Windows 研究笔记">Windows 研究笔记</a>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Windows</category>
      
      <category>Windows 研究笔记</category>
      
      <category>WSL2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Windows</tag>
      
      <tag>Windows 研究笔记</tag>
      
      <tag>WSL2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 8 及之后版本的系统还原的新行为</title>
    <link href="/zh/2021/11/02/New-behavior-of-System-Restore-since-Windows-8/"/>
    <url>/zh/2021/11/02/New-behavior-of-System-Restore-since-Windows-8/</url>
    
    <content type="html"><![CDATA[<p>从 Windows 8 开始，微软对系统还原的行为进行了变更。</p><h2 id="系统还原点最小创建时间间隔"><a href="#系统还原点最小创建时间间隔" class="headerlink" title="系统还原点最小创建时间间隔"></a>系统还原点最小创建时间间隔</h2><p>从 Windows 8 开始，系统还原点默认最小创建间隔为 24 小时。即在创建一个新的系统还原点 24 小时以内试图再创建新的系统还原点则会被跳过。</p><p>我们可以在 <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\SystemRestore</code> 注册表键下创建值为 N (单位分钟) 名为 <code>SystemRestorePointCreationFrequency</code> 的 DWORD 值来指定系统还原点的最小创建时间间隔。</p><h2 id="仅监控启动卷上的文件变更"><a href="#仅监控启动卷上的文件变更" class="headerlink" title="仅监控启动卷上的文件变更"></a>仅监控启动卷上的文件变更</h2><p>从 Windows 8 开始，系统还原仅监控启动卷上系统还原所需要捕获的文件变更。Windows 8 之后版本在其 Windows 启动卷创建的系统还原点如果被早期版本的 Windows 检测到可能会被其删除。</p><p>我们可以在 <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\SystemRestore</code> 注册表键下创建值为 0 名为 <code>ScopeSnapshots</code> 的 DWORD 值以使系统还原将以早期版本 Windows 的方式在启动卷上创建快照。</p><p>如果希望继续使用新行为，则删除该注册表键即可。</p><h2 id="原文勘误"><a href="#原文勘误" class="headerlink" title="原文勘误"></a>原文勘误</h2><p>当年在 <a href="https://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1507617&amp;page=1#pid40120249">https://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1507617&amp;page=1#pid40120249</a> 中我写的下述内容其实是有误的。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">如果你的电脑是多系统并且其中一个是 Windows XP 的话，为了解决 NT6 系统还原点和NT5的不兼容问题；<br>在 Windows 8 以后，可以这样操作使系统可以在启动卷上创建和 Windows XP 风格的还原点。<br><br>在注册表 HKLM<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows NT<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\S</span>ystemRestore 下面创建一个名为<br>ScopeSnapshots 的 DWORD 值。如果这个值为 0，系统还原将以早期版本的 Windows 的方式在启动卷上创建快照。<br>如果这个值被删除，则系统还原会按照 Windows 8 的方式创建系统还原点。<br></code></pre></td></tr></table></figure><p>当时我的理解是修改了 <code>ScopeSnapshots</code> 以后，在 Windows 8 之后的 Windows 会使用 Windows XP 或者 Windows Server 2003 的方式创建系统还原点，但实际上应该是以 Windows Vista 和 Windows 7 及其对应的服务器版本的方式创建系统还原点。</p><p>其实在最近几年我对系统还原实现进行逆向的时候，Windows Vista 之后的系统还原实现已经完全基于卷影复制实现。Windows 8 之后的系统还原实现也没有任何与 Windows XP 或者 Windows Server 2003 的系统还原有关的兼容逻辑。毕竟 Windows Vista 之前的系统还原是基于微软自己写的过滤驱动实现的，而 Windows Vista 以后早已没有该过滤驱动的相关痕迹。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/sr/calling-srsetrestorepoint?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/windows/win32/sr/calling-srsetrestorepoint?redirectedfrom=MSDN</a></li></ul><h2 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h2><a href="/zh/2021/11/02/Windows-Research-Notes/" title="Windows 研究笔记">Windows 研究笔记</a>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Windows</category>
      
      <category>Windows 研究笔记</category>
      
      <category>系统还原</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Windows</tag>
      
      <tag>Windows 研究笔记</tag>
      
      <tag>系统还原</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 研究笔记</title>
    <link href="/zh/2021/11/02/Windows-Research-Notes/"/>
    <url>/zh/2021/11/02/Windows-Research-Notes/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我是毛利。</p><p>我很喜欢撰写技术文章，尤其喜欢去远景论坛发表长篇技术贴，因为我觉得在很多人去的论坛发表文章可以让更多的人看到，使更多的人因为我写的技术文章得到帮助。</p><p>大概在 2014 到 2016 年，是我的高产期。后来我不怎么发布技术文章了，比较那时的我没有灵感写长篇技术文章。但那时的自己又没有勇气发布短篇技术文章，因为担心其他人说我在论坛水贴。</p><p>众所周知，前几年远景论坛的服务器非常不稳定，动不动就无法访问。于是那时的我萌生了把自己在远景等论坛发表的文章都归纳到自己在 GitHub 托管的博客里面。毕竟论坛不可能永远存在，但是 Git 仓库每个人都能做备份，能让我写的内容流传下去。</p><p>后来远景论坛恢复正常后，我忘记了这件事。直到最近因为一些契机，且在在友人 walterlv 的鼓励下，使得我下定决心这么做。</p><p>我并不会单纯的归档之前撰写的技术文章，而是会根据之前的内容以我现在的视角去对内容进行勘误和重写。希望借此能够减少潜在的理解错误的地方，能够更好的帮助看到我这一系列文章的读者。</p><p>如果发现了本系列文章中的错误内容，或者有更好的建议，请直接在<a href="https://github.com/MouriNaruto/MouriNaruto/issues">https://github.com/MouriNaruto/MouriNaruto/issues</a> 反馈。</p><p>注：本索引会随着本系列内容的更新而更新。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>Windows 系统还原<ul><li><a href="/zh/2021/11/02/New-behavior-of-System-Restore-since-Windows-8/" title="Windows 8 及之后版本的系统还原的新行为">Windows 8 及之后版本的系统还原的新行为</a></li><li>系统还原基本介绍</li><li>通过命令行使用系统还原</li><li>通过程序语言使用系统还原</li><li>系统还原点存储结构分析</li><li>系统还原的未文档化 Win32 API</li><li>使用 Win32 API 创建系统还原点的注意事项</li><li>使用 Win32 API 清空系统还原点的注意事项</li></ul></li><li>Compact OS<ul><li>通过 compact 命令行工具使用 Compact OS</li><li>通过 Win32 API 使用 Compact OS</li><li>Compact OS 的历史和实现原理</li></ul></li><li>App Container<ul><li>App Container 基本介绍</li><li>通过 Win32 API 使用 App Container</li><li>通过第三方工具使用 App Container</li><li>通过 NT API 创建 App Container 访问令牌及注意事项</li><li>Windows 10 及之后版本的 App Container 行为变更</li></ul></li><li>Windows 自带的 C 运行时库<ul><li>Windows 自带的 C 运行时库的历史沿革</li><li>通过 VC-LTL 使用 Windows 自带的 C 运行时库</li><li>在传统 UWP 中使用 VC-LTL</li><li>在 Rust 中使用 VC-LTL</li></ul></li><li>Windows 用户模式基础设施 (Win32 API, NT API)<ul><li>充分利用管理员权限的技巧</li><li>Windows 10 早期版本的高 DPI 支持技巧</li></ul></li><li>Windows Runtime<ul><li>通过 Windows Runtime API 实现对商店应用的升级</li><li>Windows 应用程序打包项目的已知问题和解决方案</li><li>使用 C++/WinRT 实现一个轻量级 XAML Island 应用</li><li>自定义 Windows 8.x 开始屏幕的大小</li></ul></li><li>Windows Subsystem for Linux<ul><li><a href="/zh/2021/11/02/Control-the-memory-usage-of-WSL-2-instance/" title="控制 WSL 2 实例的内存占用">控制 WSL 2 实例的内存占用</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Windows</category>
      
      <category>Windows 研究笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Windows</tag>
      
      <tag>Windows 研究笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Windows 平台上移除 ARM32 支持</title>
    <link href="/zh/2021/05/17/Drop-ARM32-support-on-the-Windows-platform/"/>
    <url>/zh/2021/05/17/Drop-ARM32-support-on-the-Windows-platform/</url>
    
    <content type="html"><![CDATA[<p>经过审慎考虑，在我为主要维护者的开源项目（譬如 NSudo）的未来版本将会移除 ARM32 支持，主要原因如下：</p><ul><li>Windows ARM32 桌面版本停滞在 Redstone 2 Insider Build 15035，虽然 ARM32 版本还有 Windows RT 8.1 和 Windows 10 IoT Core 系列没有结束支持，然而估计绝大部分非考古用途人士基本已经放弃使用相关设备（Windows RT 8.x 平板）和有更好的替代品（树莓派上使用 IoT Core ARM32 其实不如直接迁移到 Linux 或者 Windows 10 ARM64 桌面版本）。</li><li>未来的 ARM 处理器将会砍掉 ARM32 指令集支持，其实 Apple Silicon M1 已经这么做了，所以在该设备上跑的 Windows 10 ARM64 桌面版应该并不支持 ARM32 应用（毕竟 ARM64 下的 ARM32 应用支持和 x64 下的 x86 应用支持原理类似，都是硬件直接执行而不是仿真）。</li><li>对未来采用 Rust, .NET 和 Project Reunion 编写部分实现的可能性的考量，这些设施在 Windows 下大概率不会重新考虑支持 ARM32 应用开发支持。</li><li>减小发行包的体积、加快连续集成执行速度。</li></ul><p>毛利</p>]]></content>
    
    
    <categories>
      
      <category>公告</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>公告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些关于 Windows 高 DPI 支持的笔记</title>
    <link href="/zh/2021/01/05/some-notes-about-windows-high-dpi-support/"/>
    <url>/zh/2021/01/05/some-notes-about-windows-high-dpi-support/</url>
    
    <content type="html"><![CDATA[<p>前段日子，刚好遇到了一些和 Windows 高 DPI 支持有关的事情，我按照自己的经验做了一些勘误和解答了一些问题，以下是相关内容。</p><ul><li>关于对友人 walterlv 的博文进行的勘误（经我勘误的内容已加入原博文）<a href="https://blog.walterlv.com/post/windows-high-dpi-development.html">https://blog.walterlv.com/post/windows-high-dpi-development.html</a></li><li>关于对老鸭子的 YY-Thunks 项目的 ForDpi 相关 API 兼容实现的细节（等鸭子实现后再更新）</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从北京到《赛博朋克 2077》</title>
    <link href="/zh/2020/12/18/from-beijing-to-cyberpunk-2077/"/>
    <url>/zh/2020/12/18/from-beijing-to-cyberpunk-2077/</url>
    
    <content type="html"><![CDATA[<p>自从上个月的 23 日到达北京，与线上的一个友人见了一面并找到新的工作之后，就于此安顿下来。我看了看日历，看起来在北京呆了差不多一个月的，也是写点感触的时候了，顺便写最近购买的新出的《赛博朋克 2077》。</p><p>首先，我在 23 日遇到的友人经历传奇到令人肃然起敬，但是却非常低调。为了使友人能够不受打扰，在写公开内容的地方，还是不说为妙。</p><p>这篇文章这么命名的原因，主要也是希望通过写对《赛博朋克 2077》的感受顺便大致描述下我在北京的经历。</p><p>首先，《赛博朋克 2077》的新手引导个人觉得是比波兰蠢驴的上一款口碑之作《巫师3：狂猎》和米忽悠家的《原神》要友好的。至少对于我这样的玩家是这样的，基本上不会因为找不到东西而使得自己在新手引导卡住。</p><p>个人觉得新手引导的友好与否直接关乎到一个游戏是否能玩的下去，毕竟就是因为这个原因使得我玩了一天《巫师3：狂猎》才突破新手引导，毕竟杰洛特有个东西很难找。就像我大概一个月前刚到北京，如果没有我的母亲的协助的话，我也不可能很快的在北京安顿下来，说不定会弃坑。</p><p>夜之城的描绘则让我想到了北京，尤其是我暂时居住的地方，夜间和白天基本上一样繁华。再加上即使不开光线追踪的夜之城的渲染效果足够真实，让我总会想到现实生活。</p><p>倒是当时我差点选择公司开头，而不是流浪者，当然我玩的角色是个女孩子，其捏脸系统虽然不能说非常强悍，但是也让我陷入了深深的困扰，最后点了随机按钮，选择了我感觉还 OK 的外貌。倒是使用女性角色的话，你应该会感受到主角的声音非常御姐，感觉和 B 站的某个 up 主声线类似。</p><p>其驾驶系统体验挺糟糕的，让我想起了曾经我还在学校的自动驾驶实验室里摸索过的某个自动驾驶训练数据集里面训练用的一个叫Torcs 的一个跨平台的老游戏。其驾驶视角非常容易变更，不能自动跟随，于是驾驶不是很舒服。其实射击的感觉也是，感觉有点不真实。</p><p>由于我是 PC 玩家，于是没有体验到非常糟糕的主机优化。倒是……这家伙不开光追感觉拉不开特效的差距。不开光追的最高和最低特效，也就是 24 帧到 56 帧的感受，在我的笔记本上的 1060 的确是这样的。波兰蠢驴依然和以前一样有诚意，我作为从 GOG 购买的用户，额外附赠的内容还是挺不错的。其配乐倒是和巫师不同，没那么丰富比较同质化。游戏的细节做的也很认真，我主要指的是纹理和音效，还有本地化做的相当不错。</p><p>但是，我却隐约觉得波兰蠢驴没有把自己的诚意发挥在恰当的地方。譬如游戏的驾驶和射击感受，我没有体验到的海量 Bug 还有主机端的糟糕优化。</p><p>我虽然对开放世界表示不是很适应，比较能探索的内容太多会让人迷失方向。然而，赛博朋克类型的游戏不大一样，需要一些多变性的场景，否则会让人感觉在强制接受他人的经历一样。</p><p>关于这家伙跳票数次，我感觉主要原因有二，一要等英伟达的新款显卡，二因为前段日子蠢驴压榨事件而导致无法继续压榨员工于是只能跳票。说到压榨，游戏开发者从去年到今年经历了 996，让我想到了三个月前还在实验室 007 的自己。我也知道游戏是一个随时都会有大变更的项目，而且对内容的要求越来越多……于是新游戏多次跳票应该是未来的常态吧。</p><p>由于最近事情比较多，于是我卸载了这款游戏，于是我的机器上也回到了以前的没有安装第三方游戏的状态。只是为了在事情结束后再次游玩，顺便也算是跟进波兰蠢驴的对游戏口碑问题的应对方案了。</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
      <category>赛博朋克 2077</category>
      
      <category>生活</category>
      
      <category>北京</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
      <tag>赛博朋克 2077</tag>
      
      <tag>生活</tag>
      
      <tag>北京</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在我的博客仓库使用连续集成</title>
    <link href="/zh/2020/12/06/using-ci-in-my-blog-repo/"/>
    <url>/zh/2020/12/06/using-ci-in-my-blog-repo/</url>
    
    <content type="html"><![CDATA[<p>众所周知，我的这个基于 hexo 的博客是托管在一个 GitHub 仓库之中。</p><p>由于每次更新博客都需要自己通过命令行进行手动生成，所以我打算在我的博客仓库引入连续集成以实现自动构建。</p><p>一开始，我想参照我的友人落樱的博客仓库的做法，然而他用的连续集成服务我之前并没有注册过。</p><p>为了究极的偷懒，于是我去网上搜寻如何使用 AppVeyor 连续集成服务自动构建基于 hexo 的博客的文章。</p><p>首先，读者可以通过下述我也参阅过的文章去了解如何使用 AppVeyor 连续集成服务自动构建基于 hexo 的博客。</p><ul><li><a href="https://www.jianshu.com/p/58cca2054d80">Github Hexo AppVeyor个人博客搭建和持续集成</a></li><li><a href="https://blog.csdn.net/Mculover666/article/details/94837390">【Hexo搭建个人博客】（十一）使用Appveyor持续集成博客（备份Hexo博客源文件）</a></li></ul><p>毕竟，我也想偷懒，那么我也不会写其他人都会写到的内容。</p><p>当然，我也知道，如果不写点与众不同的内容，那么也对不起浪费了宝贵时间更新博客的自己。</p><p>于是，我说点我遇到的我看到的文章没有谈到的事情吧。</p><p>首先，是 AppVeyor CI 预装的 Node.js 版本过旧的问题，导致我的博客包无法正确编译。</p><p>当然，在踩过了一些坑后，解决方案也很简单，可以参阅下述内容就能轻松的解决。</p><ul><li><a href="https://github.com/appveyor/ci/issues/2921">Node 12.0 support · Issue #2921 · appveyor/ci</a></li><li><a href="https://github.com/atom/fs-admin/blob/master/appveyor.yml">fs-admin/appveyor.yml at master · atom/fs-admin</a></li></ul><p>其次，我为了更方便的管理我的个人事务，我的博客仓库从 <a href="https://github.com/MouriNaruto/MouriNaruto.github.io">https://github.com/MouriNaruto/MouriNaruto.github.io</a>迁移到了 <a href="https://github.com/MouriNaruto/MouriNaruto/tree/master/blog-source%E3%80%82">https://github.com/MouriNaruto/MouriNaruto/tree/master/blog-source。</a></p><p>毕竟 GitHub 前段日子出了个新特性，在个人的账户下放一个和个人 ID 同名的仓库可以在 GitHub 上显示特定的内容。</p><p>我觉得，既然可以这么做，那么我就把和个人介绍有关的全部内容放在这个仓库好了，这也是我这么做的理由。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>CI</tag>
      
      <tag>AppVeyor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的一些在 shapez.io 中的设计</title>
    <link href="/zh/2020/11/02/share-my-design-in-shapez-io/"/>
    <url>/zh/2020/11/02/share-my-design-in-shapez-io/</url>
    
    <content type="html"><![CDATA[<p>在三天前，我的友人魔王殿给我推荐了一款 shapez.io 的游戏。我大概玩了 20 个小时，感觉这是一款自动化生成类型的开源的沙盒游戏。这款游戏非常不错，只是我今天把其卸载了，毕竟我不想让自己沉迷其中。说的这么冠冕堂皇，其实还是接下来一段时间我需要一些重要的事情而已。（笑）</p><p>虽然是卸载了，但是过段时间我应该还会再次游玩，为了保险起见我备份了自己的存档。顺便分享下我在其中做的一些设计，当然魔王殿在这方面指点了我不少。</p><p>由于 shapez.io 只提供红绿蓝三色的直接采集，其他四色即白黄青紫需要使用颜色合成单元进行合成。</p><p>首先展示一下三色颜料合成机，也就是白色合成机的实现。</p><p><img src="three_colour_compositor.png" alt="三色颜料合成机"></p><p>由于传送带的速度为 6 个每秒，而颜色合成单元的速度为 0.6 个每秒，于是需要对其进行并行化。在这里我们只需要采用均衡器和隧道来实现把原色尽可能多的分配个颜色处理单元，然后最后使用合并器对结果进行合并，以提升传送带的利用效率。</p><p>依葫芦画瓢，同理可得双色颜料合成机，也就是黄色、青色和紫色合成机的实现。</p><p><img src="two_colour_compositor.png" alt="双色颜料合成机"></p><p>为了更好的使用采集与合成的颜料，于是我打算对其进行中心化管理，这是我引入调色盘概念的原因。下面两图分别是调色盘前端和和调色盘整体的实现。</p><p><img src="colour_palette_frontend.png" alt="调色盘前端"></p><p><img src="colour_palette_overview.png" alt="调色盘整体"></p><p>由于在后面的关卡解锁了蓝图，终于可以在其中有条件的复制粘贴了，虽然要耗费某种最终材料，下文简称蓝图。为了更方便的复制粘贴，所以我对蓝图的制造实现了自动化，下图是其整体结构。</p><p><img src="blueprint_producer_overview.png" alt="蓝图制造机整体"></p><p>虽然看起来比较复杂，但如果按照前面制造颜料合成机的方式，制造着色器和合并机就不会感觉到困难。当然，你说造起来比较麻烦，其实也不一定。因为之前解锁蓝图的时候会预先制造一些蓝图，于是你可以对一些简单的单元进行复制粘贴。详细结构可参考下图。</p><p><img src="blueprint_producer_detail.png" alt="蓝图制造机详细"></p><p>由于该游戏的通关和基本制造单元的升级条件需要制造一些奇形怪状的图形，于是设计一个高效率的切割机是必由之路。由于该游戏要求比较多，所以我只展示最基本的实现，也就是对对称图形进行切割然而输出其上半或下半部分。</p><p><img src="half_cutter.png" alt="上半和下半切割机"></p><p>对并行化的着色器、合并机和切割机的设计进行调整和组合，可以满足该游戏的大部分要求。譬如这是一个生成由四个直角梯形组成的风车图形的制造单元。</p><p><img src="complex_product_producer.png" alt="复杂单元制造"></p><p>由于我通过了第十五关，解锁了仓库，仓库可以帮助玩家更好的计划物件的生产，个人觉得这玩意类似计算机中缓冲区的概念。这是我的简单并行仓库，主要是为了通过第十六关，虽然真正通过估计要过段时间了。</p><p><img src="buffer_design.png" alt="并行仓库"></p><p>当然忘记说了，shapez.io 要通关的话，所有的产物都得交给基地，下图展示下这个要求颇多的物件。</p><p><img src="base.png" alt="基地"></p><p>总之，这游戏挺好玩的，感谢魔王殿的推荐，笑。</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
      <category>shapez.io</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
      <tag>shapez.io</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
